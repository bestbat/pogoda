#!/usr/bin/env python
from math import ceil, floor
import os
import re
import sys
from lxml import html
import requests
from prettytable import PrettyTable

def get_condition_code(language, condition):
    mapping = {
        'sr': {
            'Магла':             'CodeFog',
            'Ведро':             'CodeSunny',
            'Претежно ведро':    'CodeMostlySunny',
            'Делимично облачно': 'CodePartlyCloudy'
        }
    }
    return mapping[language][condition]

def get_ascii_art_cond(code):
    codes = {
        'CodeUnknown': [
            "    .-.      ",
            "     __)     ",
            "    (        ",
            "     `-᾿     ",
            "      •      ",
        ],
        'CodeCloudy': [
            "             ",
            "\033[38;5;250m     .--.    \033[0m",
            "\033[38;5;250m  .-(    ).  \033[0m",
            "\033[38;5;250m (___.__)__) \033[0m",
            "             ",
        ],
        'CodeFog': [
            "             ",
            "\033[38;5;251m _ - _ - _ - \033[0m",
            "\033[38;5;251m  _ - _ - _  \033[0m",
            "\033[38;5;251m _ - _ - _ - \033[0m",
            "             ",
        ],
        'CodeHeavyRain': [
            "\033[38;5;240;1m     .-.     \033[0m",
            "\033[38;5;240;1m    (   ).   \033[0m",
            "\033[38;5;240;1m   (___(__)  \033[0m",
            "\033[38;5;21;1m  ‚ʻ‚ʻ‚ʻ‚ʻ   \033[0m",
            "\033[38;5;21;1m  ‚ʻ‚ʻ‚ʻ‚ʻ   \033[0m",
        ],
        'CodeHeavyShowers': [
            "\033[38;5;226m _`/\"\"\033[38;5;240;1m.-.    \033[0m",
            "\033[38;5;226m  ,\\_\033[38;5;240;1m(   ).  \033[0m",
            "\033[38;5;226m   /\033[38;5;240;1m(___(__) \033[0m",
            "\033[38;5;21;1m   ‚ʻ‚ʻ‚ʻ‚ʻ  \033[0m",
            "\033[38;5;21;1m   ‚ʻ‚ʻ‚ʻ‚ʻ  \033[0m",
        ],
        'CodeHeavySnow': [
            "\033[38;5;240;1m     .-.     \033[0m",
            "\033[38;5;240;1m    (   ).   \033[0m",
            "\033[38;5;240;1m   (___(__)  \033[0m",
            "\033[38;5;255;1m   * * * *   \033[0m",
            "\033[38;5;255;1m  * * * *    \033[0m",
        ],
        'CodeHeavySnowShowers': [
            "\033[38;5;226m _`/\"\"\033[38;5;240;1m.-.    \033[0m",
            "\033[38;5;226m  ,\\_\033[38;5;240;1m(   ).  \033[0m",
            "\033[38;5;226m   /\033[38;5;240;1m(___(__) \033[0m",
            "\033[38;5;255;1m    * * * *  \033[0m",
            "\033[38;5;255;1m   * * * *   \033[0m",
        ],
        'CodeLightRain': [
            "\033[38;5;250m     .-.     \033[0m",
            "\033[38;5;250m    (   ).   \033[0m",
            "\033[38;5;250m   (___(__)  \033[0m",
            "\033[38;5;111m    ʻ ʻ ʻ ʻ  \033[0m",
            "\033[38;5;111m   ʻ ʻ ʻ ʻ   \033[0m",
        ],
        'CodeLightShowers': [
            "\033[38;5;226m _`/\"\"\033[38;5;250m.-.    \033[0m",
            "\033[38;5;226m  ,\\_\033[38;5;250m(   ).  \033[0m",
            "\033[38;5;226m   /\033[38;5;250m(___(__) \033[0m",
            "\033[38;5;111m     ʻ ʻ ʻ ʻ \033[0m",
            "\033[38;5;111m    ʻ ʻ ʻ ʻ  \033[0m",
        ],
        'CodeLightSleet': [
            "\033[38;5;250m     .-.     \033[0m",
            "\033[38;5;250m    (   ).   \033[0m",
            "\033[38;5;250m   (___(__)  \033[0m",
            "\033[38;5;111m    ʻ \033[38;5;255m*\033[38;5;111m ʻ \033[38;5;255m*  \033[0m",
            "\033[38;5;255m   *\033[38;5;111m ʻ \033[38;5;255m*\033[38;5;111m ʻ   \033[0m",
        ],
        'CodeLightSleetShowers': [
            "\033[38;5;226m _`/\"\"\033[38;5;250m.-.    \033[0m",
            "\033[38;5;226m  ,\\_\033[38;5;250m(   ).  \033[0m",
            "\033[38;5;226m   /\033[38;5;250m(___(__) \033[0m",
            "\033[38;5;111m     ʻ \033[38;5;255m*\033[38;5;111m ʻ \033[38;5;255m* \033[0m",
            "\033[38;5;255m    *\033[38;5;111m ʻ \033[38;5;255m*\033[38;5;111m ʻ  \033[0m",
        ],
        'CodeLightSnow': [
            "\033[38;5;250m     .-.     \033[0m",
            "\033[38;5;250m    (   ).   \033[0m",
            "\033[38;5;250m   (___(__)  \033[0m",
            "\033[38;5;255m    *  *  *  \033[0m",
            "\033[38;5;255m   *  *  *   \033[0m",
        ],
        'CodeLightSnowShowers': [
            "\033[38;5;226m _`/\"\"\033[38;5;250m.-.    \033[0m",
            "\033[38;5;226m  ,\\_\033[38;5;250m(   ).  \033[0m",
            "\033[38;5;226m   /\033[38;5;250m(___(__) \033[0m",
            "\033[38;5;255m     *  *  * \033[0m",
            "\033[38;5;255m    *  *  *  \033[0m",
        ],
        'CodePartlyCloudy': [
            "\033[38;5;226m   \\  /\033[0m      ",
            "\033[38;5;226m _ /\"\"\033[38;5;250m.-.    \033[0m",
            "\033[38;5;226m   \\_\033[38;5;250m(   ).  \033[0m",
            "\033[38;5;226m   /\033[38;5;250m(___(__) \033[0m",
            "             ",
        ],
        'CodeMostlySunny': [
            "\033[38;5;226m    \\   /    \033[0m",
            "\033[38;5;226m     .-.     \033[0m",
            "\033[38;5;226m  ‒ (   ) ‒  \033[0m",
            "\033[38;5;226m     `-᾿\033[0m.",
            "\033[38;5;226m    / \033[0m (_)",
        ],
        'CodeSunny': [
            "\033[38;5;226m    \\   /    \033[0m",
            "\033[38;5;226m     .-.     \033[0m",
            "\033[38;5;226m  ‒ (   ) ‒  \033[0m",
            "\033[38;5;226m     `-᾿     \033[0m",
            "\033[38;5;226m    /   \\    \033[0m",
        ],
        'CodeThunderyHeavyRain': [
            "\033[38;5;240;1m     .-.     \033[0m",
            "\033[38;5;240;1m    (   ).   \033[0m",
            "\033[38;5;240;1m   (___(__)  \033[0m",
            "\033[38;5;21;1m  ‚ʻ\033[38;5;228;5m⚡\033[38;5;21;25mʻ‚\033[38;5;228;5m⚡\033[38;5;21;25m‚ʻ   \033[0m",
            "\033[38;5;21;1m  ‚ʻ‚ʻ\033[38;5;228;5m⚡\033[38;5;21;25mʻ‚ʻ   \033[0m",
        ],
        'CodeThunderyShowers': [
            "\033[38;5;226m _`/\"\"\033[38;5;250m.-.    \033[0m",
            "\033[38;5;226m  ,\\_\033[38;5;250m(   ).  \033[0m",
            "\033[38;5;226m   /\033[38;5;250m(___(__) \033[0m",
            "\033[38;5;228;5m    ⚡\033[38;5;111;25mʻ ʻ\033[38;5;228;5m⚡\033[38;5;111;25mʻ ʻ \033[0m",
            "\033[38;5;111m    ʻ ʻ ʻ ʻ  \033[0m",
        ],
        'CodeThunderySnowShowers': [
            "\033[38;5;226m _`/\"\"\033[38;5;250m.-.    \033[0m",
            "\033[38;5;226m  ,\\_\033[38;5;250m(   ).  \033[0m",
            "\033[38;5;226m   /\033[38;5;250m(___(__) \033[0m",
            "\033[38;5;255m     *\033[38;5;228;5m⚡\033[38;5;255;25m *\033[38;5;228;5m⚡\033[38;5;255;25m * \033[0m",
            "\033[38;5;255m    *  *  *  \033[0m",
        ],
        'CodeVeryCloudy': [
            "             ",
            "\033[38;5;240;1m     .--.    \033[0m",
            "\033[38;5;240;1m  .-(    ).  \033[0m",
            "\033[38;5;240;1m (___.__)__) \033[0m",
            "             ",
        ]
    }
    return codes[code]

def is_int(string):
    try:
        int(string)
        return True
    except ValueError:
        return False

def parse_date_from_hidmet_dom_tree(tree):
    text = tree.xpath("//h1//text()")[0]
    pattern = re.compile(r'^Подаци са главних метеоролошких станица:  (.*)')
    match = pattern.search(text)
    date = match.group(1)
    return date

def parse_weather_report(tree, station):
    table = tree.xpath("//table/tr[td//text()[contains(., '" + station + "')]]")
    temperatura = table[0].xpath(".//td[2]//text()")[0].strip()
    pritisak = table[0].xpath(".//td[3]//text()")[0].strip()
    pravac_vetra = table[0].xpath(".//td[4]//text()")[0].strip()
    brzina_vetra = table[0].xpath(".//td[5]//text()")[0].strip()
    vlaznost = table[0].xpath(".//td[6]//text()")[0].strip()
    subj_osecaj_t = table[0].xpath(".//td[7]//text()")[0].strip()
    opis_vremena = table[0].xpath(".//td[9]//text()")[0].strip()

    return [
        ('Станица', station, ''),
        ('Температура', int(temperatura), '°C'),
        ('Притисак', float(pritisak), 'hPa'),
        ('Правац ветра', pravac_vetra, ''),
        ('Брзина ветра', int(brzina_vetra), 'm/s') if is_int(brzina_vetra)
        else ('Брзина ветра', brzina_vetra, ''),
        ('Влажност ваздуха', int(vlaznost), '%'),
        ('Субјективни осећај', int(subj_osecaj_t), '°C'),
        ('Опис времена', opis_vremena, '')
    ]

def fetch_weather_report_dom_tree_from_hidmet():
    url = 'http://www.hidmet.gov.rs/ciril/osmotreni/index.php'
    page = requests.get(url)
    tree = html.fromstring(page.content)
    return tree

def render_table(weather_data, label_pad, value_pad):
    # get ascii art from weather description
    _, condition, _ = weather_data[7]
    ascii_art = [''] + get_ascii_art_cond(get_condition_code('sr', condition))
    # prepare the table
    tbl = PrettyTable()
    tbl.field_names = ['ascii', 'name', 'value']
    tbl.header = False
    tbl.align['ascii'] = 'l'
    tbl.align['name'] = 'l'
    tbl.align['value'] = 'l'
    # fill table
    for i in range(len(weather_data)):
        label, value, unit = weather_data[i]
        ascii_art_row = ascii_art[i] if i < len(ascii_art) else ''
        value_row = f'{value} {unit}'.ljust(value_pad)
        label_row = label.ljust(label_pad)
        tbl.add_row([ascii_art_row, label_row, value_row])
    return tbl.get_string().splitlines()

STATIONS = {
    'pa'  : 'Палић',
    'so'  : 'Сомбор',
    'ns'  : 'Нови Сад',
    'bk'  : 'Б. Карловац',
    'lo'  : 'Лозница',
    'sm'  : 'С. Митровица',
    'va'  : 'Ваљево',
    'bg'  : 'Београд',
    'kg'  : 'Крагујевац',
    'sp'  : 'С. Паланка',
    'vg'  : 'В. Градиште',
    'cv'  : 'Црни Врх',
    'ne'  : 'Неготин',
    'zla' : 'Златибор',
    'sj'  : 'Сјеница',
    'po'  : 'Пожега',
    'kv'  : 'Краљево',
    'kop' : 'Копаоник',
    'ku'  : 'Куршумлија',
    'cu'  : 'Ћуприја',
    'ni'  : 'Ниш',
    'le'  : 'Лесковац',
    'za'  : 'Зајечар',
    'di'  : 'Димитровград'
}

def get_stations_by_abbrs(abbrs):
    return list(map(lambda x: STATIONS[x], abbrs))

def terminal_size():
    rows, columns = os.popen('stty size', 'r').read().split()
    return int(rows), int(columns)

def max_table_column_widths(reports):
    max_label_width = 0
    max_value_width = 0
    for report in reports:
        for item in report:
            label, value, unit = item
            label_width = len(label)
            if label_width > max_label_width:
                max_label_width = label_width
            value_width = len(f'{value} {unit}')
            if value_width > max_value_width:
                max_value_width = value_width
    return max_label_width, max_value_width


def render_tables(reports):
    label_pad, value_pad = max_table_column_widths(reports)
    return list(map(lambda x: render_table(x, label_pad, value_pad), reports))

def max_table_width(tables):
    max_width = 0
    for table in tables:
        line = table[0]
        if len(line) > max_width:
            max_width = len(line)
    return max_width

def output_tables(tables, term_columns):
    tables_per_row = floor(term_columns / max_table_width(tables))
    num_rows = ceil(len(tables) / tables_per_row)
    lines_per_table = len(tables[0])
    for row_index in range(num_rows):
        for line_index in range(lines_per_table):
            for cell_offset in range(tables_per_row):
                table_index = row_index * tables_per_row + cell_offset
                if table_index < len(tables):
                    print(tables[table_index][line_index], end='')
            print()

def parse_reports(dom_tree, stations):
    return list(map(lambda station: parse_weather_report(dom_tree, station), stations))

hidmet_dom_tree = fetch_weather_report_dom_tree_from_hidmet()
print('Подаци са главних метеоролошких станица')
date_line = parse_date_from_hidmet_dom_tree(hidmet_dom_tree)
print(date_line)
abbrs = sys.argv[1:] if len(sys.argv) > 1 else ['bg']
station_names = STATIONS.values() if abbrs[0] == 'sve' else get_stations_by_abbrs(abbrs)
reports = parse_reports(hidmet_dom_tree, station_names)
tables = render_tables(reports)

_, term_columns = terminal_size()
output_tables(tables, term_columns)
